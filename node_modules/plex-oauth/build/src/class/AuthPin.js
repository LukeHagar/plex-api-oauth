"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthPin = void 0;
var RequestHelper_1 = require("../helpers/RequestHelper");
var LinkHelper_1 = require("../helpers/LinkHelper");
var Util_1 = require("../helpers/Util");
var AuthPin = /** @class */ (function () {
    function AuthPin() {
    }
    /**
     * Request's an OAuth Pin from the Plex API, which is used to get the Auth Token
     * @param {IPlexClientDetails} clientInfo Client information to send to the Plex API
     *
     * @returns {Promise<IPlexCodeResponse>} The hosted ui URL
     */
    AuthPin.prototype.getPin = function (clientInfo) {
        return RequestHelper_1.RequestHelper.post(LinkHelper_1.LinkHelper.PLEX_PIN_BASE_PATH + "/pins?strong=true", "", __assign({}, LinkHelper_1.LinkHelper.getHeaders(clientInfo))).then(function (response) {
            return response;
        }).catch(function (err) {
            throw err;
        });
    };
    /**
     * Sends repeated requests to the Plex Pin API with the provided pin id. It will then return
     * the auth token if it gets one, or null if it runs out of retries.
     * @param {IPlexClientDetails} clientInfo Client information to send to the Plex API
     * @param {number} pinId The id of the Plex pin to query for
     * @param {number} requestDelay The delay in seconds to wait between each poll
     * @param {number} maxRetries The number of retries before returning null
     *
     * @returns {Promise<string | null>} The auth token if found or null
     */
    AuthPin.prototype.pollForAuthToken = function (clientInfo, pinId, requestDelay, maxRetries) {
        var _this = this;
        if (requestDelay < 1000) {
            requestDelay = 1000;
        }
        return RequestHelper_1.RequestHelper.get(LinkHelper_1.LinkHelper.PLEX_PIN_BASE_PATH + "/pins/" + pinId, __assign({}, LinkHelper_1.LinkHelper.getHeaders(clientInfo))).then(function (response) {
            if (response) {
                var pinData = response;
                if (pinData.authToken) {
                    return pinData.authToken;
                }
                else {
                    if (maxRetries <= 0) {
                        return null;
                    }
                    return Util_1.Util.wait(function () { return _this.pollForAuthToken(clientInfo, pinId, requestDelay, maxRetries -= 1); }, requestDelay);
                }
            }
            else {
                return null;
            }
        }).catch(function (err) {
            throw err;
        });
    };
    return AuthPin;
}());
exports.AuthPin = AuthPin;
//# sourceMappingURL=AuthPin.js.map